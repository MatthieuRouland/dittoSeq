
################# dittoDimPlot ####################

#' Shows data overlayed on a tsne, pca, or similar type of plot
#' @import ggplot2
#' @importFrom ggrepel geom_text_repel geom_label_repel
#'
#' @param var Target Variable = either values or a metadata (in "quotes"), gene (in "quotes"), or "ident"
#' @param object the Seurat or RNAseq object to work on
#' @param reduction.use "pca", "tsne", "ica", etc.  Default = tsne for Seurat objects, and pca for RNAseq objects
#' @param dim.1 The component number to use on the x-axis.  Default = 1
#' @param dim.2 The component number to use on the y-axis.  Default = 2
#' @param theme Allows setting of a theme. Default = theme_bw when nothing is provided.
#' @param size Number. Size of data points.  Default = 1.
#' @param shape Number for setting shape OR name of metadata to use for setting shape
#' @param shapes the shapes to use.  Default is a list of 6.  There are more, but not many of the default ggplot options are great.  I recommend using colors for any variable with 7+ options.
#' @param legend.show TRUE/FALSE. Whether the legend should be displayed. Default = TRUE.
#' @param legend.size The size to increase the plotting of colors/letters legend shapes to (for discrete variable plotting)
#' @param legend.title For adding a title for the colors/letters legend.  It is set to NULL (off) by default.
#' @param shape.legend.size The size to increase the plotting of shapes legend shapes to.
#' @param shape.legend.title For adding a title for the shapes legend is a meta.data was given to 'shape' and multiple shapes were therefore used.  It is set to NULL (off) by default.
#' @param data.type For when plotting expression data, sets the data-type slot that will be obtained. See \link[DittoSeq]{gene} for options and details. DEFAULT = "normalized".
#' @param main plot title.  Default = "make", if left as "make", a title will be autogenerated based on the var input
#' @param sub plot subtitle
#' @param xlab label for y axes.  Default labels are generated if you do not give this a specific value.  To remove, set to NULL.
#' @param ylab label for y axes.  Default labels are generated if you do not give this a specific value.  To remove, set to NULL.
#' @param cells.use cells to show: either in the form of a character list of names, or a logical that is the same length as the number of cells in the object (a.k.a. *THIS*: object@cell.names[*THIS*])
#' @param show.others TRUE/FALSE. TRUE by default, whether other cells should be shown in the background
#' @param ellipse TRUE/FALSE. Whether the groups should be surrounded by an ellipse.
#' @param do.label  TRUE/FALSE. Whether to add text labels at the center (median) of clusters for grouping vars
#' @param label.size Size of the the labels text
#' @param highlight.labels TRUE/FALSE. Whether the labels should have a box behind them
#' @param labels.repel TRUE/FALSE. Whether the labels' placements should be adjusted to avoid covering underlying cells.
#' FALSE by defualt as it is untested.
#' @param rename.var.groups new names for the identities of var.  Change to NULL to remove labeling altogether.
#' @param rename.shape.groups new names for the identities of shape groups.  Change to NULL to remove labeling altogether.
#' @param min.color color for lowest values of var/min
#' @param max.color color for highest values of var/max
#' @param min set the value associated with the minimum color.  All points with a lower value than this will get the same min.color.
#' @param max set the value associated with the maximum color.  All points with a higher value than this will get the same max.color.  Note: if your legend is not plotting, it's likely because min > max.
#' @param color.panel a list of colors to be used for when plotting a discrete var.
#' @param colors indexes / order of colors from color.panel to use. USAGE= changing the order of how colors are linked to specific groups
#' @param do.letter TRUE/FALSE/NA. Whether letters should be added on top of the colored dots. For colorblindness compatibility.  NA by default, and if left that way, will be set to either TRUE or FALSE depending on the number of groups if a discrete var is given. For when there are lots of descrete variables, it can be hard to see by just color / shape.  NOTE: Lettering is incompatible with changing dots to shapes, so this will override a setting of distinct shapes based on the 'shape' variable!
#' @param do.hover TRUE/FALSE. Default = FALSE.  If set to true: object will be converted to a ggplotly object so that data about individual points will be displayed when you hover your cursor over them.  'data.hover' argument is used to determine what data to use.  NOTE: incompatible with lettering (due to a ggplotly incompatibility). Setting do.hover to TRUE will override a do.letter=TRUE or NA.
#' @param data.hover list of variable names, c("meta1","gene1","meta2","gene2"). determines what data to show on hover when do.hover is set to TRUE.
#' @param opacity Number between 0 and 1. Great for when you have MANY overlapping points, this sets how see-through the points should be; 1 = not at all; 0 = invisible. Default = 1.
#' @param add.trajectories List vectors representing trajectory paths from start-cluster to end-cluster where vector contents are the names of clusters provided in the \code{trajectory.clusters} input.
#' If Slingshot package was used for trajectory analysis, you can use \code{SlingshotDataSet(SCE_with_slingshot)$lineages}.
#' @param trajectory.clusters String name of metadata containing the clusters that were used for generating trajectories.  Names of clusters must be the same as the contents of \code{add.trajectories} vectors.
#' @param trajectory.arrow.size Number representing the size of trajectory arrows in inches.  Default = 0.15.
#' @param data.out Whether just the plot should be output, or a list with the plot and Target_data and Others_data dataframes.  Note: plotly output is turned off in this setting, but hover.data is still calculated.
#' @return Makes a plot where colored dots (or other shapes) are overlayed onto a tSNE, PCA, CCA, ..., plot of choice.  var is the argument that sets how dots will be colored, and it can refer to either continuous (ex: "CD34" = gene expression) or discrete (ex: "ident" = clustering) data.
#' @details
#' If \code{data=TRUE}, a list containing the plot (p), a data.table containing the underlying data for target cells (Target_data), and a data.table containing the underlying data for non-target cells (Others_data).
#' @export
#' @examples
#' library(Seurat)
#' pbmc <- Seurat::pbmc_small
#' dittoDimPlot("RNA_snn_res.1", object = "pbmc")
#' #To show currently set clustering, you can use "ident".
#' #To change the dimensional reduction type, use reduction.use.
#' #MANY other tweaks are possible!
#' dittoDimPlot("ident", object = "pbmc", reduction.use = "pca", ellipse = TRUE, do.label = TRUE)
#'
#' # Note: if DEFAULT <- "pbmc" is run beforehand, the object input can be skipped completely.
#' DEFAULT <- "pbmc"
#' dittoDimPlot("RNA_snn_res.1")
#' dittoDimPlot("ident", reduction.use = "pca", ellipse = TRUE, do.label = TRUE)

dittoDimPlot <- function(var="ident", object = DEFAULT, reduction.use = NA, dim.1 = 1, dim.2 = 2,
                         theme = NA, size=1, shape=16, shapes=c(16,15,17,23,25,8),
                         legend.show = TRUE, legend.size = 5, legend.title = NULL,
                         shape.legend.size = 5, shape.legend.title = NULL,
                         data.type = "normalized",
                         main = "make", sub = NULL, xlab = "make", ylab = "make",
                         cells.use = NULL, show.others=TRUE, ellipse = FALSE,
                         do.label = FALSE, label.size = 5, highlight.labels = TRUE, labels.repel = FALSE,
                         rename.var.groups = NA, rename.shape.groups = NA,
                         min.color = "#F0E442", max.color = "#0072B2", min = NULL, max = NULL,
                         color.panel = MYcolors, colors = 1:length(color.panel),
                         do.letter = NA, do.hover = FALSE, data.hover = var,
                         opacity = 1, data.out = FALSE,
                         add.trajectories = NULL, trajectory.clusters, trajectory.arrow.size = 0.15){
  #Turn the object into a "name" if a full object was given
  if (typeof(object)=="S4"){
    object <- deparse(substitute(object))
  }
  #Generate the x/y dimensional reduction data and axes labels.
  #If reduction.use = NA (was not provided), populate it to be tsne or pca.
  if (grepl("Seurat",classof(object)) & is.na(reduction.use)) {reduction.use <- "tsne"}
  if (classof(object)=="SingleCellExperiment" & is.na(reduction.use)) {reduction.use <- "TSNE"}
  if (classof(object)=="RNAseq" & is.na(reduction.use)) {reduction.use <- "pca"}
  xdat <- extDim(reduction.use, dim.1, object)
  ydat <- extDim(reduction.use, dim.2, object)
  #Standardize cells.use to a list of names.
  cells.use <- which_cells(cells.use, object)
  #Establish the full list of cell/sample names
  all.cells <- all_cells(object)
  #Set Titles
  if (!(is.null(xlab))) { if (xlab=="make") { xlab <- xdat$name } }
  if (!(is.null(ylab))) { if (ylab=="make") { ylab <- ydat$name } }
  if (!is.null(main)){ if (main == "make") {
    if (length(var)==1) { main <- var } else { main <- NULL }
  } }
  #Unless theme was set in some way, remove gridlines for umap's and tsne's.
  if (is.na(theme)){
    theme <- theme_bw()
    if (grepl("tsne|umap", tolower(reduction.use))){theme <- theme + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())}
  }
  #Set whether lettering or hover and/or shaping will happen.  do.hover >> do.letter >> shape by discrete variables
  #Decide if letters should be added or not
  #If#1) if do.hover was set to TRUE, lettering will not work, so set to FALSE.
  if(do.hover){
    do.letter <- FALSE
  } else {
    #IF#2) if do.letter was already set, we'll just go with what the user wanted!
    if(is.na(do.letter)){
      #If#2) if the data is discrete, continue. (Otherwise, it is continuous so letters would not make sense!)
      if(!(is.numeric(var_OR_get_meta_or_gene(var, object=object, data.type=data.type)))){
        #If#3) if the number of groups is 8 or more, letters are recommended.
        if(length(levels(as.factor(var_OR_get_meta_or_gene(var, object=object, data.type=data.type))))>=8){
          do.letter <- TRUE
        } else { do.letter <- FALSE }
      } else { do.letter <- FALSE }
    }
  }
  p.df <- dittoScatterPlot(x.var = xdat$embeddings, y.var = ydat$embeddings, overlay.color.var = var,
                           if(!do.letter & is.character(shape)){overlay.shape.var = shape},
                           if(!do.letter & is.numeric(shape)){shape = shape},
                           object = object, cells.use = cells.use, show.others = show.others,
                           color.panel = color.panel, colors = colors,
                           data.type.color = data.type,
                           rename.color.groups = rename.var.groups, rename.shape.groups = rename.shape.groups,
                           do.hover = do.hover, data.hover = data.hover, data.type.hover = data.type,
                           shapes = shapes, size = size, opacity = opacity,
                           legend.show = legend.show, legend.color.title = legend.title,
                           legend.color.size = legend.size, legend.shape.size = legend.size,
                           min.color = min.color, max.color = max.color, min = min, max = max,
                           xlab = xlab, ylab = ylab, main = main, sub = sub, theme = theme,
                           data.out = TRUE)
  p <- p.df$plot
  Target_data <- p.df$Target_data
  Others_data <- p.df$Others_data

  #Add letters if warranted
  if(do.letter){
    letter.labels <- c(LETTERS, letters, 0:9, "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "-",
                       "+", "_", "=", ";", "/", "|", "{", "}", "~")[seq_along(levels(as.factor(Target_data$color)))]
    names(letter.labels) <- levels(as.factor(Target_data$color))
    letter.colors <- c(rep("white",7), rep("black",10),rep("white",9))[seq_along(levels(as.factor(Target_data$color)))]
    names(letter.colors) <- levels(as.factor(Target_data$color))
    p <- p +
      geom_point(data=Target_data, aes(x = X, y = Y, shape = color), color = "black", size=size, alpha = opacity*3/4) +
      scale_shape_manual(name = legend.title,
                         values = letter.labels)
    guides(shape = guide_legend(override.aes = list(size=shape.legend.size)))
  }
  #Add ellipse
  if (ellipse) { p <- p + stat_ellipse(data=Target_data, aes(x = X, y = Y, colour = color),
                                       type = "t", linetype = 2, size = 0.5, show.legend = FALSE)}
  #Add labels
  if(do.label) { p <- dittoDimPlot.addLabels(p, Target_data, highlight.labels, rename.var.groups, label.size, labels.repel)}
  #Add trajectories
  if(!is.null(add.trajectories)) {
    p <- dittoDimPlot.addTrajectory(
      p, trajectories = add.trajectories, clusters = trajectory.clusters, arrow.size = trajectory.arrow.size,
      object = object, reduction.use = reduction.use, dim.1 = dim.1, dim.2 = dim.2)}
  #Remove legend, if warrented
  if (!legend.show) { p <- remove_legend(p) }
  ### RETURN the PLOT ###
  if(data.out){return(list(plot = p,
                           Target_data = Target_data,
                           Others_data = Others_data))}
  else{
    if(do.hover){ return(plotly::ggplotly(p, tooltip = "text")) }
    else { return(p) }
  }
}

dittoDimPlot.addLabels <- function(p, Target_data, highlight.labels, rename.groups, label.size, labels.repel) {
  #Make a text plot at the median x and y values for each cluster
  #Determine medians
  cent.x = sapply(levels(as.factor(Target_data[,3])), function(X) median(Target_data$X[Target_data[,3]==X]))
  cent.y = sapply(levels(as.factor(Target_data[,3])), function(X) median(Target_data$Y[Target_data[,3]==X]))
  #Add labels
  args <- list(
      data = data.frame(x=cent.x, y=cent.y),
      aes(x = x, y = y, label = if(!(is.na(rename.groups[1]))){rename.groups} else {levels(as.factor(Target_data[,3]))}),
      size = label.size)
  if (highlight.labels){
      #Add labels with a white background
      if (labels.repel) { p <- p + do.call(geom_label_repel, args) }
      else { p <- p + do.call(geom_label, args) }
  } else {
      #Add labels without a white background
      if (labels.repel) { p <- p + do.call(geom_text_repel, args) }
      else { p <- p + do.call(geom_text, args) }
  }
  p
}

dittoDimPlot.addTrajectory <- function(p, trajectories, clusters, arrow.size = 0.15, object, reduction.use, dim.1, dim.2) {
  # p = the $p output of a dittoDimPlot(any.var,..., data.out = TRUE) in the same dimensional reduction space and dims as Target_data is built on, though can be any data, not just the original clustering
  # Target_data = the $Target output of a dittoDimPlot("clustering.meta.data.name", data.out = TRUE) where "clustering.meta.data.name" is the name of the metadata slot that holds the clusters used for slingshot::getLineages
  # trajectories = List os lists of cluster paths. Also, the output of SlingshotDataSet(SCE_with_slingshot)$lineages
  # arrow.size = numeric scalar that sets the arrow length (in inches) at the endpoints of trajectory lines.
  #
  #Determine medians
  data <- data.frame(cent.x = sapply(meta.levels(clusters, object),
                                     function(X) median(extDim(reduction.use, dim.1, object)$embedding[meta(clusters, object)==X])),
                     cent.y = sapply(meta.levels(clusters, object),
                                     function(X) median(extDim(reduction.use, dim.2, object)$embedding[meta(clusters, object)==X])))
  #Add trajectories
  for (i in seq_along(trajectories)){
    p <- p + geom_path(data = data[trajectories[[i]],],
                       aes(x = cent.x, y = cent.y),
                       arrow = arrow(angle = 20, type = "closed", length = unit(arrow.size, "inches")))
  }
  p
}

#### multi_dittoDimPlot : a function for quickly making multiple DBDimPlots arranged in a grid.
#' Generates multiple dittoDimPlots arranged in a grid.
#'
#' @param vars               c("var1","var2","var3",...). REQUIRED. A list of vars from which to generate the separate plots
#' @param object             the Seurat or RNAseq object to draw from = REQUIRED, unless `DEFAULT <- "object"` has been run.
#' @param show.legend        TRUE/FALSE. Whether or not you would like a legend to be plotted.  Default = FALSE
#' @param ncol               #. How many plots should be arranged per row.  Default = 3 unless \code{length(vars)} is shorter.
#' @param nrow               #/NULL. How many rows to arrange the plots into.  Default = NULL(/blank) --> becomes however many rows are needed to show all the data.
#' @param axes.labels        TRUE/FALSE. Whether a axis labels should be added
#' @param OUT.List           TRUE/FALSE. (Default = FALSE) Whether the output should be a list of objects instead of the full plot.  Outputting as list allows manual input into gridArrange for moving plots around / adjusting sizes.  In the list, all plots will be named by the variable being shown.
#' @param ...                other paramters that can be given to DBDimPlot function used in exactly the same way.
#' @return Given multiple 'var' parameters, this function will output a DBDimPlot for each one, arranged into a grid.  All parameters that can be adjusted in DBDimPlot can be adjusted here, but the only parameter that can be adjusted between each is 'var'.
#' @examples
#' library(Seurat)
#' pbmc <- Seurat::pbmc_small
#' genes <- c("CD8A","CD3E","FCER1A","CD14","MS4A1")
#' multi_dittoDimPlot(c(genes, "ident"), object = "pbmc")
#' # Note: if DEFAULT <- "pbmc" is run beforehand, the object input can be skipped completely.
#' DEFAULT <- "pbmc"
#' multi_dittoDimPlot(c(genes, "ident"))
#' @export

multi_dittoDimPlot <- function(vars, object = DEFAULT,
                              show.legend = FALSE,
                              ncol = min(3,length(vars)), nrow = NULL,
                              axes.labels=FALSE,
                              OUT.List = FALSE,
                              ...){

  #Interpret axes.labels: If left as FALSE, set lab to NULL so they will be removed.
  # If set to TRUE, set it to "make".
  lab <- if(!axes.labels) {NULL} else {"make"}

  plots <- lapply(vars, function(X) {
    dittoDimPlot(X, object,
              xlab = lab,
              ylab = lab,
              ...) + theme(legend.position = ifelse(show.legend, "right", "none"))
  })
  if (OUT.List){
    names(plots) <- vars
    return(plots)
  } else {
    return(gridExtra::grid.arrange(grobs=plots, ncol = ncol, nrow = nrow))
  }
}
