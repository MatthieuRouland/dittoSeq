################# DBDimPlot ####################

#' (Deprecated) Shows data overlayed on a tsne, pca, or similar type of plot
#' @import ggplot2
#'
#' @param var Target Variable = either values or a metadata (in "quotes"), gene (in "quotes"), or "ident"
#' @param object the Seurat or RNAseq object to work on
#' @param reduction.use "pca", "tsne", "ica", etc.  Default = tsne for Seurat objects, and pca for RNAseq objects
#' @param dim.1 The component number to use on the x-axis.  Default = 1
#' @param dim.2 The component number to use on the y-axis.  Default = 2
#' @param theme Allows setting of a theme. Default = theme_bw when nothing is provided.
#' @param size Number. Size of data points.  Default = 1.
#' @param shape Number for setting shape OR name of metadata to use for setting shape
#' @param shapes the shapes to use.  Default is a list of 6.  There are more, but not many of the default ggplot options are great.  I recommend using colors for any variable with 7+ options.
#' @param legend.show TRUE/FALSE. Whether the legend should be displayed. Default = TRUE.
#' @param legend.size The size to increase the plotting of colors/letters legend shapes to (for discrete variable plotting)
#' @param legend.title For adding a title for the colors/letters legend.  It is set to NULL (off) by default.
#' @param shape.legend.size The size to increase the plotting of shapes legend shapes to.
#' @param shape.legend.title For adding a title for the shapes legend is a meta.data was given to 'shape' and multiple shapes were therefore used.  It is set to NULL (off) by default.
#' @param data.type For when plotting expression data: Should the data be "normalized" (data slot), "raw" (raw.data or counts slot), "scaled" (the scale.data slot of Seurat objects), "relative" (= pulls normalized data, then uses the scale() function to produce a relative-to-mean representation), or "normalized.to.max" (= pulls normalized data, then divides by the maximum value)? DEFAULT = "normalized"
#' @param main plot title.  Default = "make", if left as "make", a title will be autogenerated based on the var input
#' @param sub plot subtitle
#' @param xlab label for y axes.  Default labels are generated if you do not give this a specific value.  To remove, set to NULL.
#' @param ylab label for y axes.  Default labels are generated if you do not give this a specific value.  To remove, set to NULL.
#' @param cells.use cells to show: either in the form of a character list of names, or a logical that is the same length as the number of cells in the object (a.k.a. *THIS*: object@cell.names[*THIS*])
#' @param show.others TRUE/FALSE. TRUE by default, whether other cells should be shown in the background
#' @param ellipse TRUE/FALSE. Whether the groups should be surrounded by an ellipse.
#' @param do.label  TRUE/FALSE. Whether to add text labels at the center (median) of clusters for grouping vars
#' @param label.size Size of the the labels text
#' @param highlight.labels TRUE/FALSE. Whether the labels should have a box behind them
#' @param rename.groups new names for the identities of var.  Change to NULL to remove labeling altogether.
#' @param min.color color for lowest values of var/min
#' @param max.color color for highest values of var/max
#' @param min set the value associated with the minimum color.  All points with a lower value than this will get the same min.color.
#' @param max set the value associated with the maximum color.  All points with a higher value than this will get the same max.color.  Note: if your legend is not plotting, it's likely because min > max.
#' @param color.panel a list of colors to be used for when plotting a discrete var.
#' @param colors indexes / order of colors from color.panel to use. USAGE= changing the order of how colors are linked to specific groups
#' @param do.letter TRUE/FALSE/NA. Whether letters should be added on top of the colored dots. For colorblindness compatibility.  NA by default, and if left that way, will be set to either TRUE or FALSE depending on the number of groups if a discrete var is given. For when there are lots of descrete variables, it can be hard to see by just color / shape.  NOTE: Lettering is incompatible with changing dots to shapes, so this will override a setting of distinct shapes based on the 'shape' variable!
#' @param do.hover TRUE/FALSE. Default = FALSE.  If set to true: object will be converted to a ggplotly object so that data about individual points will be displayed when you hover your cursor over them.  'data.hover' argument is used to determine what data to use.  NOTE: incompatible with lettering (due to a ggplotly incompatibility). Setting do.hover to TRUE will override a do.letter=TRUE or NA.
#' @param data.hover list of variable names, c("meta1","gene1","meta2","gene2"). determines what data to show on hover when do.hover is set to TRUE.
#' @param opacity Number between 0 and 1. Great for when you have MANY overlapping points, this sets how see-through the points should be; 1 = not at all; 0 = invisible. Default = 1.
#' @return Makes a plot where colored dots (or other shapes) are overlayed onto a tSNE, PCA, ICA, ..., plot of choice.  var is the argument that sets how dots will be colored, and it can refer to either continuous (ex: "CD34" = gene expression) or discrete (ex: "ident" = clustering) data.
#' @examples
#'
#' library(Seurat)
#' pbmc <- Seurat::pbmc_small
#' DBDimPlot("RNA_snn_res.1", object = "pbmc")
#' DBDimPlot("ident", object = "pbmc", reduction.use = "pca", ellipse = TRUE, do.label = TRUE)
#' # Note: if DEFAULT <- "pbmc" is run beforehand, the object input can be skipped completely.
#' DEFAULT <- "pbmc"
#' DBDimPlot("RNA_snn_res.1")
#' DBDimPlot("ident", reduction.use = "pca", ellipse = TRUE, do.label = TRUE)
#' @export

DBDimPlot <- function(var="ident", object = DEFAULT, reduction.use = NA, dim.1 = 1, dim.2 = 2, theme = NA,
                      size=1, shape=16, shapes=c(16,15,17,23,25,8),
                      legend.show = TRUE, legend.size = 5, legend.title = NULL,
                      shape.legend.size = 5, shape.legend.title = NULL,
                      data.type = "normalized",
                      main = "make", sub = NULL, xlab = "make", ylab = "make",
                      cells.use = NULL, show.others=TRUE, ellipse = FALSE,
                      do.label = FALSE, label.size = 5, highlight.labels = TRUE,
                      rename.groups = NA,
                      min.color = "#F0E442", max.color = "#0072B2", min = NULL, max = NULL,
                      color.panel = MYcolors, colors = 1:length(color.panel),
                      do.letter = NA, do.hover = FALSE, data.hover = var,
                      opacity = 1){

  #Change object to character if not already
  object <- S4_2string(object)

  #Populate cells.use with a list of names if it was given anything else.
  cells.use <- which_cells(cells.use, object)
  #Establish the full list of cell/sample names
  all.cells <- all_cells(object)

  #If reduction.use = NA (was not provided), populate it to be tsne or pca.
  if (grepl("Seurat",classof(object)) & is.na(reduction.use)) {reduction.use <- "tsne"}
  if (classof(object)=="SingleCellExperiment" & is.na(reduction.use)) {reduction.use <- "TSNE"}
  if (classof(object)=="RNAseq" & is.na(reduction.use)) {reduction.use <- "pca"}

  #Generate the x/y dimensional reduction data and axes labels.
  xdat <- extDim(reduction.use, dim.1, object)
  ydat <- extDim(reduction.use, dim.2, object)
  #If xlab/ylab left as "make", use default axis labels generated in the extDim call (ex. "tSNE_1" or "PC2").
  if (!(is.null(xlab))) {
    if (xlab=="make") {
      xlab <- xdat$name
    }
  }
  if (!(is.null(ylab))) {
    if (ylab=="make") {
      ylab <- ydat$name
    }
  }

  #Build data for populating dat, the data.frame for plotyting.
  #Determine the identity of the provided 'var' and populate Y, the variable used for coloring.
  Y <- var_OR_get_meta_or_gene(var, object, data.type)

  #Decide if letters should be added or not
  #If#1) if do.hover was set to TRUE, lettering will not work, so set to FALSE.
  if(do.hover){
    do.letter <- FALSE
  } else {
    #IF#2) if do.letter was already set, we'll just go with what the user wanted!
    if(is.na(do.letter)){
      #If#2) if the data is discrete, continue. (Otherwise, it is continuous so letters would not make sense!)
      if(!(is.numeric(Y))){
        #If#3) if the number of groups is 8 or more, letters are recommended.
        if(length(levels(as.factor(Y)))>=8){
          do.letter <- TRUE
        } else { do.letter <- FALSE }
      } else { do.letter <- FALSE }
    }
  }
  #Determine the identity of the provided 'shape'.
  #If it is a meta.data name, pull the meta.  else (it is a number) just carry it through
  if(typeof(shape)=="character"){
    if(do.letter){Shape <- shapes[1]
    } else {Shape <- meta(shape, object)}
  } else {Shape <- shape}

  #Groundwork for plotly hover data:
  #This does: if do.hover=TRUE and data.hover has a list of genes / metas,
  # then for all cells, make a string "var1: var1-value\nvar2: var2-value..."
  hover.string <- NA
  if (do.hover) {
    hover.string <- make_hover_strings(data.hover, object, data.type)
  }

  #Populate the data.frame to be used for plotting
  full_dat <- data.frame(Y = Y,
                         dim1 = xdat$embeddings,
                         dim2 = ydat$embeddings,
                         size = size,
                         shape = Shape,
                         Group = Y,
                         hover.string = hover.string)

  #Subset to cells.use
  Others_dat <- full_dat[!(all.cells %in% cells.use),]
  Target_dat <- full_dat[cells.use,]

  ## Groundwork for adding letter labeling of dots
  # If adding letters, create a vector of what those labels should be
  if(do.letter){
    letter.labels <- c(LETTERS, letters, 0:9, "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "-",
                       "+", "_", "=", ";", "/", "|", "{", "}", "~")[seq_along(levels(as.factor(Y)))]
    names(letter.labels) <- levels(Y)
    letter.colors <- c(rep("white",7), rep("black",10),rep("white",9))[seq_along(levels(as.factor(Y)))]
    names(letter.colors) <- levels(Y)
  }

  ###Start building the plot###
  p <- ggplot() + ylab(ylab) + xlab(xlab)

  #Then Add more layers:

  ###Add the data###
  #Make gray dots on the bottom layer if show.others = TRUE and cells.use is a subset of all the cells / samples.
  if (show.others & dim(Others_dat)[1]>1) {
    p <- p + geom_point(data=Others_dat,
                        if(do.hover){aes(x = dim1, y = dim2, text = hover.string)}else{aes(x = dim1, y = dim2)},
                        size=0.5, color = "gray90")
  }
  #Overlay the target data on top
  # If 'shape' input was the name of a meta.data, aka type=character, treat shape as an aesthetic for performing grouping.
  # Otherwise it is a number and belongs outside of aes.
  if (typeof(shape)=="character" & !do.letter) {
    p <- p + geom_point(data=Target_dat,
                        if(do.hover){aes(x = dim1, y = dim2, colour = Y, shape=shape, text = hover.string)
                        }else{aes(x = dim1, y = dim2, colour = Y, shape=shape)},
                        size=size,
                        alpha = opacity) +
      # if(do.letter){geom_point(data=Target_dat, aes(x = dim1, y = dim2, shape = Y), color = letter.colors, size=size)} +
      scale_shape_manual(values = shapes[seq_along(levels(as.factor(Target_dat$shape)))],
                         labels = levels(as.factor(as.character(Target_dat$shape))))
  }  else {
    p <- p + geom_point(data=Target_dat,
                        if(do.hover){aes(x = dim1, y = dim2, colour = Y, text = hover.string)}
                        else{aes(x = dim1, y = dim2, colour = Y)},
                        shape= Shape, size=size, stroke = 0, alpha = opacity)
    if(do.letter){
      p <- p +
        geom_point(data=Target_dat, aes(x = dim1, y = dim2, shape = Y), color = "black", size=size/2, alpha = opacity) +
        scale_shape_manual(name = legend.title,
                           values = letter.labels#,
                           # if(!(is.na(rename.groups[1]))){
                           #   labels = rename.groups}
        )
    }
  }

  ###Add ellipse###
  ### Draw an ellipse if ellipse = TRUE.
  if (ellipse) { p <- p + stat_ellipse(data=Target_dat,
                                       aes(x = dim1, y = dim2, colour = Y),
                                       type = "t",
                                       linetype = 2,
                                       size = 0.5,
                                       show.legend = FALSE
  )}

  ###Add titles###
  #If left as default ("make") try to autogenerate a main title based on the identity of `var`.
  if (!is.null(main)){
    #If var is a meta.data (includes "ident") or gene, make the title = var.
    if (main == "make" & length(var)==1 & is.character(var) & (is.meta(var, object) | is.gene(var, object))){
      main <- var
    }
    if (main == "make") {main <- NULL}
  }
  #Add titles to plot
  p <- p + ggtitle(main,sub)

  ### Add Labels ###
  if (do.label) {
    #Make a text plot at the median x and y values for each cluster
    #Determine medians
    cent.1 = sapply(levels(as.factor(Target_dat$Y)), function(X) median(Target_dat$dim1[Target_dat$Y==X]))
    cent.2 = sapply(levels(as.factor(Target_dat$Y)), function(X) median(Target_dat$dim2[Target_dat$Y==X]))
    #Add labels
    if (highlight.labels){
      #Add labels with a white background
      p <- p +
        geom_label(data = data.frame(x=cent.1, y=cent.2),
                   aes(x = x, y = y, label = if(!(is.na(rename.groups[1]))){rename.groups} else {levels(as.factor(Target_dat$Y))}),
                   size = label.size)
    } else {
      #Add labels without a white background
      p <- p +
        geom_text(data = data.frame(x=cent.1, y=cent.2),
                  aes(x = x, y = y, label = if(!(is.na(rename.groups[1]))){rename.groups} else {levels(as.factor(Target_dat$Y))}),
                  size = label.size)
    }
  }

  ### Set the colors ###
  ### Also change the size of the dots in the legend if showing groupings ###
  #If var yielded a list of groups for plotting (should be in the form of a list of strings = character, or a factor = integer)
  if (!(is.numeric(Y))){
    #If the number of levels/groups is less than the length of the color.panel, use the color.panel set.
    if (length(levels(as.factor(as.character(Target_dat$Y))))<=length(color.panel[colors])){
      #If labels.rename was changed from NA, rename the grouping labels to rename.groups values
      if (!(is.na(rename.groups[1]))){
        p <- p+ scale_colour_manual(name = legend.title,
                                    values = color.panel[colors],
                                    labels = rename.groups)
      } else {
        #If not, just set the colors and name for the legend key
        p <- p+ scale_colour_manual(name = legend.title,
                                    values = color.panel[colors])
      }
      #Also change the legend properties.
      if (!is.null(legend.size)){
        #First, change the size of the dots in the legend, unless legend.size was set to NULL
        #Also, set the legend title.  Given input if given, or remove if still null.
        if(do.letter){
          p <- p + guides(colour = guide_legend(override.aes = list(size=legend.size)))
        } else {
          p <- p + guides(colour = guide_legend(override.aes = list(size=legend.size)),
                          shape = guide_legend(override.aes = list(size=shape.legend.size), title = shape.legend.title))
        }
      }
    }
  } else {
    #Otherwise, the data is continous, so set a gradient that goes from 'min.color' input color to 'max.color' input color.
    p <- p + scale_color_gradient(low= min.color, high = max.color, limits = c(ifelse(is.null(min), min(Target_dat$Y), min),
                                                                               ifelse(is.null(max), max(Target_dat$Y), max)),
                                  #Next, set the legend title.  Given input if given, or remove if still null.
                                  name = legend.title)
  }

  ### Set the theme ###
  #Use theme_bw if 'theme' = NA (was not provided), or use prettyplot.1 if "prettyplot" was provided, or
  # use provided theme if a full one is provided, aka = a list.
  if (is.na(theme)){
    p <- p + theme_bw() +
      if (grepl("tsne|umap", tolower(reduction.use))){theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())}
  } else {
    p <- p + theme
  }

  #Remove legend, if warrented
  if (!legend.show) { p <- remove_legend(p) }

  ### RETURN the PLOT ###
  if(do.hover){
    return(plotly::ggplotly(p, tooltip = "text"))
  } else {
    return(p)
  }
}

#### multiDBDimPlot : a function for quickly making multiple DBDimPlots arranged in a grid.
#' (Deprecated) Generates multiple DBDimPlots arranged into a grid.
#'
#' @param vars               c("var1","var2","var3",...). REQUIRED. A list of vars from which to generate the separate plots
#' @param object             the Seurat or RNAseq object to draw from = REQUIRED, unless `DEFAULT <- "object"` has been run.
#' @param show.legend        TRUE/FALSE. Whether or not you would like a legend to be plotted.  Default = FALSE
#' @param ncol               #. How many plots should be arranged per row.  Default = 3.
#' @param nrow               #/NULL. How many rows to arrange the plots into.  Default = NULL(/blank) --> becomes however many rows are needed to show all the data.
#' @param axes.labels        TRUE/FALSE. Whether a axis labels should be added
#' @param OUT.List           TRUE/FALSE. (Default = FALSE) Whether the output should be a list of objects instead of the full plot.  Outputting as list allows manual input into gridArrange for moving plots around / adjusting sizes.  In the list, all plots will be named by the variable being shown.
#' @param ...                other paramters that can be given to DBDimPlot function used in exactly the same way.
#' @return Given multiple 'var' parameters, this function will output a DBDimPlot for each one, arranged into a grid.  All parameters that can be adjusted in DBDimPlot can be adjusted here, but the only parameter that can be adjusted between each is 'var'.
#' @examples
#' library(Seurat)
#' pbmc <- Seurat::pbmc_small
#' genes <- c("CD8A","CD3E","FCER1A","CD14","MS4A1")
#' multiDBDimPlot(c(genes, "ident"), object = "pbmc")
#' # Note: if DEFAULT <- "pbmc" is run beforehand, the object input can be skipped completely.
#' DEFAULT <- "pbmc"
#' multiDBDimPlot(c(genes, "ident"))
#' @export

multiDBDimPlot <- function(vars, object = DEFAULT,
                           show.legend = FALSE,
                           ncol = 3, nrow = NULL,
                           axes.labels=FALSE,
                           OUT.List = FALSE,
                           ...){

  #Interpret axes.labels: If left as FALSE, set lab to NULL so they will be removed.
  # If set to TRUE, set it to "make".
  lab <- if(!axes.labels) {NULL} else {"make"}

  plots <- lapply(vars, function(X) {
    DBDimPlot(X, object,
              xlab = lab,
              ylab = lab,
              ...) + theme(legend.position = ifelse(show.legend, "right", "none"))
  })
  if (OUT.List){
    names(plots) <- vars
    return(plots)
  } else {
    return(gridExtra::grid.arrange(grobs=plots, ncol = ncol, nrow = nrow))
  }
}

##################### multiDBDimPlot_vary_cells #######################
#' Generates multiple DBDimPlots, each showing different cells, arranged into a grid.
#'
#' @param var                name of a "gene", "meta.data", "ident", or a vector the length of the #cells or #samples in 'object'. REQUIRED. A var with which to color the separate plots.  Referencing discrete or continuous data are both allowed.
#' @param object             the Seurat or RNAseq object to draw from = REQUIRED, unless `DEFAULT <- "object"` has been run.
#' @param cells.use.meta     The name of the meta.data that will be used for selecting cells. REQUIRED.
#' @param cells.use.levels   The values/groupings of the cells.use.meta that you wish to show. NOTE: these will be put into the plot's main title in order to have them be identifiable.
#' @param all.cells.plot     TRUE/FALSE, whether a plot showing all of the cells should be included at the end.
#' @param show.legend        TRUE/FALSE. Whether or not you would like a legend to be plotted in every plot.  Default = FALSE
#' @param add.single.legend  TRUE/FALSE, whether to add a single legend as an additional plot.
#' @param ncol               #. How many plots should be arranged per row.  Default = 3.
#' @param nrow               #/NULL. How many rows to arrange the plots into.  Default = NULL(/blank) --> becomes however many rows are needed to show all the data.
#' @param add.title          TRUE/FALSE. Whether a title should be added.
#' @param axes.labels        TRUE/FALSE. Whether a axis labels should be added.
#' @param main               For setting a title for each individual plot.  Options: Leave as "make" and the titles will be which cells are in each plot.  "any.text" will set the same title for all plots.  NULL or "" will remove the titles.
#' @param all.cells.main     For setting the title of the All.cells plot.  Default is All Cells.  Set to NULL or "" to remove.
#' @param min                Works as in DimPlot, not required to be given, but sets the value associated with the minimum color.  All points with a lower value than this will get the same min.color.
#' @param max                Works as in DimPlot, not required to be given, but sets the value associated with the maximum color.  All points with a higher value than this will get the same max.color.
#' @param ...                other paramters that can be given to DBDimPlot function used in the same way.
#' @param data.type          As with regular DBDimPlotting, For when plotting expression data: Should the data be "normalized" (data slot), "raw" (raw.data or counts slot), "scaled" (the scale.data slot of Seurat objects), "relative" (= pulls normalized data, then uses the scale() function to produce a relative-to-mean representation), or "normalized.to.max" (= pulls normalized data, then divides by the maximum value)? DEFAULT = "normalized"
#' @param OUT.List           TRUE/FALSE. (Default = FALSE) Whether the output should be a list of objects instead of the full plot.  Outputting as list allows manual input into gridArrange for moving plots around / adjusting sizes.  In the list, the All.cells plot will be named "all" and the legend will be named "legend". Others will be named by which cells are in them.
#' @return A function for quickly making multiple DBDimPlots arranged in a grid, where instead of varying the 'var' displayed, what varies is the cells that are shown. Most parameters that can be adjusted in DBDimPlot can be adjusted here, but the only parameter that can be adjusted between each plot is which cells get displayed. NOTE: This function is incompatible with changing the 'colors' input. If you need to change the order of when certain colrs are chosen, change the order in color.panel. Also note: if 'var' given refers to continuous data, then the min and max will be calculated at the beginning in order to make the scale consistent accross all plots.  You can still set your own range, and this would also create a consistent scale.
#' @examples
#' library(Seurat)
#' pbmc <- Seurat::pbmc_small
#' multiDBDimPlot_vary_cells("CD14", object = "pbmc", cells.use.meta = "ident")
#' # Note: if DEFAULT <- "pbmc" is run beforehand, the object input can be skipped completely.
#' DEFAULT <- "pbmc"
#' multiDBDimPlot_vary_cells("CD14", cells.use.meta = "ident")
#' @export

multiDBDimPlot_vary_cells <- function(var, object = DEFAULT,
                                      cells.use.meta,
                                      cells.use.levels = meta.levels(cells.use.meta,object),
                                      all.cells.plot = TRUE,
                                      show.legend = FALSE,
                                      add.single.legend = TRUE,
                                      ncol = 3, nrow = NULL,
                                      add.title=TRUE, axes.labels=FALSE,
                                      min = NULL, max = NULL,
                                      data.type = "normalized",
                                      OUT.List = FALSE,
                                      all.cells.main = "All Cells",
                                      ...){

  #Interpret axes.labels: If left as FALSE, set lab to NULL so they will be removed.
  # If set to TRUE, set it to "make".
  lab <- if(!axes.labels) {NULL} else {"make"}

  #Determine if var is continuous vs discrete
  continuous <- FALSE
  if ((is.gene(var[1], object)) | (is.numeric(var))){
    continuous <- TRUE
  }
  if (is.meta(var[1], object)){
    if (is.numeric(meta(var,object))){
      continuous <- TRUE
    }
  }

  #Set a range if the var represents continuous data, (is.gene() or typeof(meta)!=integer OR character).
  if(continuous){
    the.range <- range(var_OR_get_meta_or_gene(var,object, data.type))
    min <- ifelse(is.null(min), the.range[1], min)
    max <- ifelse(is.null(max), the.range[2], max)
  }

  #Case 1: If var and cells.use.meta are NOT equal:
  #Need to ensure that colors are consistent.
  if(var[1] != cells.use.meta){
    #If data is continuous, then setting the range above has done the job of ensuring color consistency.
    if (continuous){
      plots <- lapply(cells.use.levels, function(X) {
        DBDimPlot(var, object,
                  cells.use = meta(cells.use.meta,object) == X,
                  xlab = lab,
                  ylab = lab,
                  main = X,
                  min = min, max = max,
                  data.type = data.type,
                  ...) +
          theme(legend.position = ifelse(show.legend, "right", "none"))
      })
      names(plots) <- cells.use.levels
    } else { #If data is discrete, then we need to make sure the right colors are use in each plot!
      levels <- meta.levels(var,object)
      plots <- lapply(cells.use.levels, function(X) {
        in.this.plot <- (seq_along(levels))[levels %in%
                                             levels(as.factor(meta(var,object)[meta(cells.use.meta,object)==X]))]
        DBDimPlot(var, object,
                  cells.use = meta(cells.use.meta,object) == X,
                  xlab = lab,
                  colors = in.this.plot,
                  ylab = lab,
                  main = X,
                  min = min, max = max,
                  data.type = data.type,
                  ...) +
          theme(legend.position = ifelse(show.legend, "right", "none"))
      })
      names(plots) <- cells.use.levels
    }
  }
  #Case 2: If var and cells.use.meta are equal
  #Need to vary the color with each new plot.
  if(var[1] == cells.use.meta){
    levels <- meta.levels(cells.use.meta, object)
    plots <- lapply((seq_along(levels))[levels %in% cells.use.levels], function(X) {
      DBDimPlot(var, object,
                cells.use = meta(cells.use.meta,object) == levels[X],
                colors = X,
                xlab = lab,
                ylab = lab,
                main = levels[X],
                min = min, max = max,
                data.type = data.type,
                ...) +
        theme(legend.position = ifelse(show.legend, "right", "none"))
    })
    names(plots) <- cells.use.levels
  }
  #Generate all.cells.plot and legend explanation
  all.plot <- DBDimPlot(var, object,
                        xlab = lab,
                        ylab = lab,
                        min = min, max = max,,
                        data.type = data.type,
                        main = all.cells.main,
                        ...)
  legend <- cowplot::ggdraw(cowplot::get_legend(all.plot))
  if (all.cells.plot){
    plots$all <- all.plot + theme(legend.position = ifelse(show.legend, "right", "none"))
  }
  if (add.single.legend){
    plots$legend <- legend
  }
  if(OUT.List){
    return(plots)
  } else {
    return(gridExtra::grid.arrange(grobs=plots, ncol = ncol, nrow = nrow))
  }
}
