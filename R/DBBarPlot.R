
########## DBBarPlot: Builds a stacked bar plot to show the composition of samples / ages / 'group.by' ##########
#' Outputs a stacked bar plot to show the percent composition of samples or other cell groupings
#' @import ggplot2
#'
#' @param var                    Target Variable = values, OR a metadata in "quotes". REQUIRED. Length must be same  as the number of cells in the Seurat object or Samples in the RNAseq object
#' @param object                 the Seurat or RNAseq object to draw from = name of object in "quotes". REQUIRED, unless `DEFAULT <- "object"` has been run.
#' @param group.by               "metadata" to use for separating values. REQUIRED (Default is to use a metadata named "Sample").
#' @param cells.use              Cells to include: either in the form of a character list of names, or a logical that is the same length as the number of cells in the object (a.k.a. *USE* in object@cell.names[*USE*])
#' @param color.panel            the set of colors to draw from
#' @param colors                 indexes / or order, of colors from color.panel to actual use
#' @param do.hover               TRUE/FALSE. Default = FALSE.  If set to true, object will be converted to a ggplotly object so that data about individual bars will be displayed when you hover your cursor over them.  Data displayed will be the "counts" and "percentage of total".'data.hover' argument is not used with this plotting function.
#' @param theme                  Allows setting of a theme. Default = theme_classic() when nothing is provided.
#' @param xlab                   "character". The text title for the x axis.  NULL/blank by default.
#' @param ylab                   "character". The text title for the y axis.  Auto-generated by default.  Provide ylab = NULL to remove
#' @param x.labels               Replacement x-axis labels to use instead of the identities of gorup.by
#' @param rotate.labels          TRUE/FALSE. whether the labels should be rotated.  Default = FALSE = vertical labels.
#' @param y.breaks               The numerical labels for the y axis.  Note: The percentages that build this figure will always add up to 1, so the plot will always go from 0 to 1.
#' @param main                   "character". Plot main title.
#' @param sub                    "character". Plot subtitle.
#' @param rename.groups          new names for the identities of var.  Change to NULL to remove labeling altogether.
#' @param legend.show            TRUE/FALSE. Whether the legend should be displayed. Default = TRUE.
#' @param legend.title           Title for the legend.  Default = blank / NULL
#' @param reorder.x              sequence of numbers from 1:length(meta.levels(group.by)) for providing a new order for the samples.  Default = alphabetical then numerical.
#' @return Makes a plot where discrete data is shown on the y-axis as "percent of total" in a stacked barplot, grouped by sample, age, cluster, etc., on the x-axis.
#' @examples
#' library(Seurat)
#' pbmc <- pbmc_small
#' DBBarPlot("ident", object = "pbmc", group.by = "orig.ident")
#' #For real data, you will have more distinct samples than this truncated dataset.
#' # Note: if DEFAULT <- "pbmc" is run beforehand, the object input can be skipped completely.
#' DEFAULT <- "pbmc"
#' DBBarPlot("ident", group.by = "orig.ident")
#' @export

DBBarPlot <- function(var="ident", object = DEFAULT, group.by = "Sample",
                      cells.use = NULL,
                      color.panel = MYcolors, colors = c(1:length(color.panel)),
                      do.hover = FALSE, theme = theme_classic(),
                      xlab = NULL, ylab = "make", x.labels = NA, rotate.labels = TRUE,
                      y.breaks = c(0,0.5,1),
                      main = "make", sub = NULL, rename.groups = NA,
                      legend.show = TRUE, legend.title = NULL,
                      reorder.x = seq_along(meta.levels(group.by, object))
){

  #Turn the object into a "name" if a full object was given
  if (typeof(object)=="S4"){ object <- deparse(substitute(object)) }

  #Populate cells.use with a list of names if it was given anything else.
  cells.use <- which_cells(cells.use, object)
  #Establish the full list of cell/sample names
  all.cells <- all_cells(object)

  ####Retrieve metas: var, group.by
  #var to y.var
  #If name of meta in "quotes", obtain the meta
  if(length(var)==1 & typeof(var)=="character") {
    if (is.meta(var, object)){
      y.var <- as.factor(meta(var, object))
    }
  } else {y.var <- var}
  #group.by to x.var
  #If name of meta in "quotes", obtain the meta
  if(length(group.by)==1 & typeof(group.by)=="character") {
    if (is.meta(group.by, object)){
      x.var <- as.factor(meta(group.by, object))
    }
  }
  #Subset the x.var and y.var to only the cells in cell.use.
  x.var <- as.factor(as.character(x.var[all.cells %in% cells.use]))
  y.var <- y.var[all.cells %in% cells.use]
  #Reorder x groupings (steps 1 and 2)
  #1-Rename the x.var labels in order to set their order.
  #2-Store originals in orig.names.
  #3-Names will be set back to orig.names or x.labels further down on in the code.
  if (typeof(reorder.x)=="integer"){
    reorder.x <- as.character(unlist(sapply(reorder.x, function(X) ifelse(X<10,paste0("0",X),X))))
  }
  orig.names <- levels(x.var)
  levels(x.var) <- reorder.x

  #Groundwork for plotly hover data:
  #Overall: if do.hover=TRUE and data.hover has a list of genes / metas,
  # then for all cells, make a string "var1: var1-value\nvar2: var2-value..."
  hover.string <- NA
  if (do.hover) {
      features.info <- data.frame(
          name = rep(meta.levels(var, object), length(levels(x.var))),
          y.counts = c(sapply(
              levels(as.factor(x.var)),
              function(X) {
                  unlist(sapply(levels(as.factor(y.var)), function(Y)
                    #Number of Xs that are Ys
                    sum(y.var==Y & x.var == X)))
                  })),
          y.percents = c(sapply(
              levels(as.factor(x.var)),
              function(X) {
                  unlist(sapply(
                      levels(as.factor(y.var)),
                      function(Y) {
                          #Number of Xs that are Ys, divided by the total number of Xs.
                          sum(y.var==Y & x.var == X)/sum(x.var == X)
                      }))
                })))
      names(features.info)<-c("Identity","Count","Percent of total")
      hover.string <- sapply(1:nrow(features.info), function(row){
        paste(as.character(sapply(1:ncol(features.info), function(col){
          paste0(names(features.info)[col],": ",features.info[row,col])})),collapse = "\n")
      })
  }

  #Build data (Make a dataframe while calculating the percent makeup of x.var groups by y.var identities.)
  #Generate the x.grouping data (needs to be the identities of x.var each individually repeated
  # the number of times that there are distinct levels in the var / y.var.)
  dat <- data.frame(grouping = c(sapply(levels(as.factor(x.var)), function(X) rep(X, length(levels(as.factor(y.var)))))),
                    #Label the y.ident that this perentage is for. (Used for coloring)
                    y.ident = rep(levels(as.factor(y.var)), length(levels(as.factor(x.var)))),
                    #Generate the percents
                    y.percents = c(sapply(levels(as.factor(x.var)), function(X)
                      unlist(sapply(levels(as.factor(y.var)), function(Y)
                        #Number of Xs that are Ys, divided by the total number of Xs.
                        sum(y.var==Y & x.var == X)/sum(x.var == X)
                      ))
                    )),
                    hover.string = hover.string
  )

  #Build Plot
  p <- ggplot(data=dat, aes(x = grouping)) + theme +
    #Add the bars.
    if(do.hover){
      geom_col(aes(y=y.percents, fill = y.ident, text = hover.string))
    } else {
      geom_col(aes(y=y.percents, fill = y.ident))
    }
  #Populate ylab if left as "make".
  if(!(is.null(ylab))){
    if(ylab == "make"){ ylab <- paste0("Percent of ",
                                       ifelse(grepl("RNAseq",classof(object)),
                                              "samples",
                                              "cells"))
    }
  }
  #Add the y-axis labels and name to the plot
  p <- p + scale_y_continuous(breaks= y.breaks,
                              limits = c(0,1),
                              name = ylab)
  ###Set the colors & and rename the groupings
  #If labels.rename was changed from NA, rename the labels to rename.groups
  if (!(is.na(rename.groups[1]))){
    p <- p+ scale_fill_manual(name = legend.title,
                              values = color.panel[colors],
                              labels = rename.groups)
  } else {
    #If not, just set the colors and name for the legend key
    p <- p+ scale_fill_manual(name = legend.title,
                              values = color.panel[colors])
  }

  #Set var to default if 'main' left as "make".
  if (!(is.null(main))){
    if (main=="make" & length(var)==1){
      main <- var
    }
    if (main=="make"){
      main <- NULL
    }
  }

  #Add the x axis title, plot title and subtitle,
  p <- p + xlab(xlab) +
    ggtitle(main, subtitle = sub) +
    theme(axis.text.x= element_text(size=10)) +
    if (rotate.labels) {theme(axis.text.x= element_text(angle=45, hjust = 1.3, vjust = 1.2, size=12))} +
    theme(legend.title=element_text(size=12)) +
    theme(legend.text=element_text(size=14))

  #Rename the x-axis labels if an x.labels was given.
  if (!(is.na(x.labels[1]))){
    p <- p + scale_x_discrete(labels=x.labels)
  } else {
    # If it was not given, put the orig.names back
    p <- p + scale_x_discrete(labels=orig.names[order(reorder.x)])
  }

  #Remove legend, if warrented
  if (!legend.show) { p <- remove_legend(p) }

  #DONE. Return the plot
  if(do.hover){
    return(plotly::ggplotly(p, tooltip = "text"))
  } else {
    return(p)
  }
}
