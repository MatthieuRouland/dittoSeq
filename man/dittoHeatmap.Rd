% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dittoHeatmap.R
\name{dittoHeatmap}
\alias{dittoHeatmap}
\title{Outputs a heatmap of given genes}
\usage{
dittoHeatmap(genes = NULL, object = DEFAULT, cells.use = NULL,
  main = NA, cell.names.meta = NULL, data.type = "normalized",
  heatmap.colors = colorRampPalette(c("blue", "white", "red"))(50),
  scaled.to.max = FALSE,
  heatmap.colors.max.scaled = colorRampPalette(c("white", "red"))(25),
  col.annotation.metas = NULL, annotation.colors = rep(dittoColors(),
  10), data.out = FALSE, highlight.genes = NULL,
  show.colnames = TRUE, show.rownames = TRUE, ...)
}
\arguments{
\item{genes}{String vector, c("gene1","gene2","gene3",...) = the list of genes to put in the heatmap. REQUIRED.}

\item{object}{String name of the object to draw from.  Alternatively, the \code{\link[Seurat]{Seurat}},  or \code{\linkS4class{RNAseq}}, or \code{\link[SingleCellExperiment]{SingleCellExperiment}} object itself. REQUIRED, unless `DEFAULT <- "object"` has been run.}

\item{cells.use}{String vector of cell/sample names to include, OR logical vector that is the same length as the number of cells in the object.}

\item{main}{String that sets the title for the heatmap.}

\item{cell.names.meta}{quoted "name" of a meta.data slot to use for naming the columns instead of using the raw cell/sample names.}

\item{data.type}{String. Options are "normalized" (data slot, default), "raw" (raw.data or counts slot), "scaled" (the scale.data slot of Seurat objects). Note: scaling is performed on the data matrix by default.}

\item{heatmap.colors}{the colors to use within the heatmap.
Default is a ramp from navy to white to red with 50 slices.}

\item{scaled.to.max}{Logical which sets whether expression shoud be scaled between [0, 1].
This is recommended for single-cell datasets as they are generally enriched in 0s.}

\item{heatmap.colors.max.scaled}{the colors to use within the heatmap when \code{scaled.to.max} is set to \code{TRUE}.
Default is a ramp from white to red with 25 slices.}

\item{col.annotation.metas}{String name of a metadata slot containing how the cells/samples should be annotated.}

\item{annotation.colors}{String (color) vector where each color will be assigned to an individual annotation in the generated annotation bars.}

\item{data.out}{Logical that changes the output of the function.
If set to \code{TRUE}, the output will be a list containing the data that would have been used for generating the heatmap,
and a String showing how \code{\link[pheatmap]{pheatmap}} would have been called.}

\item{highlight.genes}{String vector of genes whose names you would like to show. Only these genes will be named in the resulting heatmap.}

\item{show.rownames, show.colnames}{Logical which sets whether rownames or colnames will be shown.
Note: if gene names are provided to \code{highlight.genes}, the \code{show.colnames} parameter is ignored.}

\item{...}{other arguments passed to \code{pheatmap}.}
}
\value{
A \code{pheatmap} object.
Alternatively, if \code{data.out} was set to \code{TRUE}, a list containing
\code{args} = a list of arguments passed to \code{pheatmap}, and
and \code{call} = String showing how \code{pheatmap} would have been called.
}
\description{
Given a set of genes, cells/samples, and metadata names for column annotations, it will retrieve the expression data for those genes and cells, and the annotation data for those cells.
It will then utilize these data to make a heatmap using the \code{\link[pheatmap]{pheatmap}} function of the \code{pheatmap} package.
}
\note{
For scRNAseq data, running with \code{cluster_cols=FALSE} first is recommended because clustering of thousands of cells can tak a long time!
}
\examples{
library(Seurat)
pbmc <- Seurat::pbmc_small
dittoHeatmap(c("MS4A1","GNLY","CD3E","CD14","FCER1A",
    "FCGR3A","LYZ","PPBP","CD8A"),
    object = pbmc,
    col.annotation.metas = "ident")
# For real single cell data, you will have more cells than
#   in this truncated dataset,
#   so turning off cell clustering when trying out tweaks is recommended.
#   Do so by adding cluster_cols=FALSE
dittoHeatmap(c("MS4A1","GNLY","CD3E","CD14","FCER1A",
    "FCGR3A","LYZ","PPBP","CD8A"),
    object = pbmc,
    col.annotation.metas = "ident",
    cluster_cols=FALSE)

# When there are many cells, showing names becomes less useful.
  # Names can be turned off with the show.colnames parameter.
dittoHeatmap(c("MS4A1","GNLY","CD3E","CD14","FCER1A",
    "FCGR3A","LYZ","PPBP","CD8A"),
    object = pbmc,
    col.annotation.metas = "ident",
    cluster_cols=FALSE,
    show.colnames = FALSE)

# Additionally, it is recommended for single-cell data that the parameter
#   scaled.to.max be set to TRUE, because these data are generally enriched
#   for zeros that otherwise get scaled to a negative value.
dittoHeatmap(c("MS4A1","GNLY","CD3E","CD14","FCER1A",
    "FCGR3A","LYZ","PPBP","CD8A"),
    object = pbmc,
    col.annotation.metas = "ident",
    scaled.to.max = TRUE)

# Note: if DEFAULT <- "pbmc" is run beforehand, the object input can be skipped completely.
DEFAULT <- "pbmc"
dittoHeatmap(c("MS4A1","GNLY","CD3E","CD14","FCER1A",
    "FCGR3A","LYZ","PPBP","CD8A"),
    col.annotation.metas = "ident",
    scaled.to.max = TRUE)

}
\seealso{
\code{\link[pheatmap]{pheatmap}}, for how to add additional heatmap tweaks.
Some examples of useful \code{pheatmap} parameters are:
\itemize{
\item \code{cluster_cols} and \code{cluster_rows} for controlling clustering
\item \code{treeheight_row} and \code{treeheight_col} for setting how large the trees on the side/top should be drawn.
\item \code{cutree_col} and \code{cutree_row} for spliting the heatmap based on kmeans clustering
}
}
